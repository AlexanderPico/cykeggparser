package org.cytoscape.keggparser.com;


import java.util.*;

public class Graph {
    private String name = "";
    private String organism = "";
    private String number = "";
    private String title = "";
    private String image = "";
    private String link = "";
    private TreeMap<Integer, KeggNode> nodes;
    private List<KeggNode> groupNodes;
    private ArrayList<KeggRelation> relations;


    public Graph() {
        nodes = new TreeMap<Integer, KeggNode>();
        relations = new ArrayList<KeggRelation>();
    }

    public void setPathwayName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getOrganism() {
        return organism;
    }

    public void setOrganism(String organism) {
        if (organism != null)
            this.organism = organism;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        if (number != null)
            this.number = number;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        if (image != null)
            this.image = image;
    }

    public String getLink() {
        return link;
    }

    public void setLink(String link) {
        if (link != null)
            this.link = link;
    }

    public TreeMap<Integer, KeggNode> getNodes() {
        return nodes;
    }

    public void setNodes(TreeMap<Integer, KeggNode> nodes) {
        this.nodes = nodes;
    }

    public ArrayList<KeggRelation> getRelations() {
        return relations;
    }

    public void setRelations(ArrayList<KeggRelation> relations) {
        this.relations = relations;
    }

    public void addNode(KeggNode node) {
        nodes.put(node.getId(), node);
    }

    public KeggNode getNode(int id) {
        return nodes.get(id);
    }

    public void addRelation(KeggRelation relation) {
        if (!relations.contains(relation))
            relations.add(relation);
    }

    public List<KeggNode> getNeighbors(KeggNode node) {
        List<KeggNode> neiggbors = new ArrayList<KeggNode>();
        for (KeggRelation relation : relations) {
            if (relation.getEntry1().equals(node))
                neiggbors.add(relation.getEntry2());
            else if (relation.getEntry2().equals(node))
                neiggbors.add(relation.getEntry1());
        }
        return neiggbors;
    }

    public List<KeggRelation> getIncidentEdges(KeggNode node) {
        List<KeggRelation> edges = new ArrayList<KeggRelation>();
        for (KeggRelation relation : relations)
            if (relation.getEntry1().equals(node) || relation.getEntry2().equals(node))
                edges.add(relation);
        return edges;
    }

    public boolean edgeExists(KeggNode node1, KeggNode node2) {
        for (KeggRelation relation : relations)
            if (relation.getEntry1().equals(node1) && relation.getEntry2().equals(node2))
                return true;
        return false;
    }

    public KeggRelation getRelation(KeggNode node1, KeggNode node2) {
        for (KeggRelation relation : relations)
            if (relation.getEntry1().equals(node1) && relation.getEntry2().equals(node2))
                return relation;
        return null;
    }


    public void flagGroupNodes() {
        for (Map.Entry<Integer, KeggNode> nodeEntry : nodes.entrySet()) {
            KeggNode node = nodeEntry.getValue();
            if (node.getType().equals(KeggNode.GROUP)) {
                for (int compId : node.getComponentIds()) {
                    getNode(compId).setGroupFlag(node.getId());
                }
            }
        }
    }

    public void processGroups() {
        ParsingReportGenerator.getInstance().appendLine("Group node processing ON");
        String groupNodes = "";
        ArrayList<KeggNode> groupNodesList = new ArrayList<>();
        for (Map.Entry<Integer, KeggNode> keggNodeEntry : nodes.entrySet()) {
            if (keggNodeEntry.getValue().getType().equals(KeggNode.GROUP)) {
                KeggNode groupNode = keggNodeEntry.getValue();
                ArrayList<KeggNode> components = new ArrayList<KeggNode>();
                groupNodesList.add(groupNode);
                groupNodes += groupNode.getId() + ":";
                for (int id : groupNode.getComponentIds()) {
                    components.add(getNode(id));
                    groupNodes += id + ",";
                }
                groupNodes += ";";

                //Copy group edges to the
                KeggNode inNode = null;
                KeggNode outNode;
                ArrayList<KeggNode> inComponents = new ArrayList<>();
                ArrayList<KeggNode> outComponents = new ArrayList<>();
                ArrayList<KeggNode> biComponents = new ArrayList<>();
                ArrayList<KeggNode> incomingNodes = new ArrayList<>();
                ArrayList<KeggNode> outgoingNodes = new ArrayList<>();
                ArrayList<KeggNode> incomingGroupNodes = new ArrayList<>();
                ArrayList<KeggNode> outgoingGroupNodes = new ArrayList<>();

                //Sort nodes according to indegree and outdegree composition
                for (KeggNode node : nodes.values()) {

                    if (edgeExists(node, groupNode)) {
                        if (!incomingGroupNodes.contains(node))
                            incomingGroupNodes.add(node);
                    } else if (edgeExists(groupNode, node)) {
                        if (!outgoingGroupNodes.contains(node))
                            outgoingGroupNodes.add(node);
                    }
                    int size = components.size();
                    for (KeggNode component : components) {
                        if (edgeExists(node, component)) {
                            if (!incomingNodes.contains(node))
                                incomingNodes.add(node);
                            if (outComponents.contains(component)) {
                                if (!biComponents.contains(component))
                                    biComponents.add(component);
                                outComponents.remove(component);
                            } else if (!inComponents.contains(component))
                                inComponents.add(component);
                        } else if (edgeExists(component, node)) {
                            if (inComponents.contains(component)) {
                                if (!biComponents.contains(component))
                                    biComponents.add(component);
                                inComponents.remove(component);
                            } else if (!outComponents.contains(component))
                                outComponents.add(component);
                            if (!outgoingNodes.contains(node))
                                outgoingNodes.add(node);
                        }
                    }

                }

                for (KeggNode component : inComponents)
                    components.remove(component);
                for (KeggNode component : outComponents)
                    components.remove(component);
                for (KeggNode component : biComponents)
                    components.remove(component);

                KeggNode prevNode = null;

                if (biComponents.size() > 0) {
                    if (inComponents.size() > 0) {
                        if (outComponents.isEmpty())
                            for (KeggNode biNode : biComponents) {
                                if (!outComponents.contains(biNode))
                                    outComponents.add(biNode);
                            }
                    } else for (KeggNode biNode : biComponents) {
                        if (!inComponents.contains(biNode))
                            inComponents.add(biNode);
                    }
                }



                    /*
                    Make the first node the innode. Remove all other incomming edges and move them to
                    the innode.
                     */
                if (inComponents.size() > 0) {
                    inNode = inComponents.get(0);
                    prevNode = inNode;
                    inComponents.remove(0);
                    if (inComponents.size() > 0)
                        for (KeggNode componentNode : inComponents) {
                            for (KeggNode incomingNode : incomingNodes)
                                if (edgeExists(incomingNode, componentNode)) {
                                    redirectEdge(incomingNode, componentNode, incomingNode, inNode);
                                }
                            connectNodes(prevNode, componentNode);
                            prevNode = componentNode;
                        }

                } else if (components.size() > 0) {
                    inNode = components.get(0);
                    components.remove(0);
                    prevNode = inNode;
                } else if (outComponents.size() > 0) {
                    inNode = outComponents.get(0);
                }


                while (components.size() > 0) {
                    if (prevNode != null)
                        connectNodes(prevNode, components.get(0));
                    prevNode = components.get(0);
                    components.remove(0);
                }
                    /*
                    Make the first node the outNode. Remove all the edges from other
                    components in outComponents and redirect them from the outNode.
                     */
                if (outComponents.size() > 0) {
                    outNode = outComponents.get(0);
                    outComponents.remove(0);
                    if (outComponents.size() > 0)
                        for (KeggNode componentNode : outComponents) {
                            for (KeggNode outgoingNode : outgoingNodes)
                                if (edgeExists(componentNode, outgoingNode)) {
                                    redirectEdge(componentNode, outgoingNode, outNode, outgoingNode);
                                }
                            if (prevNode != null)
                                connectNodes(prevNode,componentNode);
                            prevNode = componentNode;
                        }
                    connectNodes(prevNode, outNode);
                } else
                    outNode = prevNode;

                /*
                Add the edges to the group node to the inNode and outNode.
                Remove group node.
                 */
                if (!incomingGroupNodes.isEmpty())
                    for (KeggNode incomingGroupNode : incomingGroupNodes) {
                        redirectEdge(incomingGroupNode, groupNode, incomingGroupNode, inNode);
                    }
                if (!outgoingGroupNodes.isEmpty())
                    for (KeggNode outgoingGroupNode : outgoingGroupNodes) {
                        redirectEdge(groupNode, outgoingGroupNode, outNode, outgoingGroupNode);
                    }
                for (KeggNode outGoingNode : outgoingNodes) {
                    if (edgeExists(inNode, outGoingNode)) {
                        redirectEdge(inNode, outGoingNode, outNode, outGoingNode);
                    }
                }

                for (KeggNode inComingNode : incomingNodes) {
                    if (edgeExists(inComingNode, outNode)) {
                        redirectEdge(inComingNode, outNode, inComingNode, inNode);
                    }
                }

                ParsingReportGenerator.getInstance().appendLine("Group node " + groupNode.getId() + " processed");
//                removeNode(groupNode);

            }
        }
        removeGroupNodes(groupNodesList);

    }

    private void connectNodes(KeggNode source, KeggNode target) {
        if (!edgeExists(source, target))
            if (!edgeExists(target, source)) {
                KeggRelation relation = new KeggRelation(source, target, KeggRelation.PPrel);
                addRelation(relation);
            }
    }


    private KeggRelation redirectEdge(KeggNode prevSource, KeggNode prevTarget,
                                       KeggNode newSource, KeggNode newTarget) {
        KeggRelation prevEdge = getRelation(prevSource, prevTarget);

        if (prevEdge != null) {
            removeRelation(prevEdge);
            KeggRelation newEdge = new KeggRelation(newSource,
                    newTarget, KeggRelation.PPrel);
            addRelation(newEdge);
            return newEdge;
        } else {
            System.out.println("No interaction exists between " + prevSource.getId() + ": " +
                    prevTarget.getId());
            return null;
        }
    }

    private void removeGroupNodes(ArrayList<KeggNode> groupNodes) {
        for (KeggNode node : groupNodes) {
            removeNode(node);
            ParsingReportGenerator.getInstance().appendLine("Group node " + node.getId() + ": " +
                    node.getCellName() + " processed and removed.");
        }
    }

    private void removeGroupNodes() {
        for (KeggNode node : groupNodes) {
            removeNode(node);
            ParsingReportGenerator.getInstance().appendLine("Group node " + node.getId() + ": " +
                    node.getCellName() + " processed and removed.");
        }
    }

    public void removeRelation(KeggRelation relation) {
        if (relations.contains(relation))
            relations.remove(relation);
    }

    public void removeNode(KeggNode node) {
        Integer key = 0;
        for (Map.Entry<Integer, KeggNode> entry : nodes.entrySet())
            if (entry.getValue().equals(node)) {
                key = entry.getKey();
            }
        nodes.remove(key);
    }

    public void processCompounds() {
        ParsingReportGenerator.getInstance().appendLine("Compound relation processing ON");
        List<KeggRelation> compoundRelations = new ArrayList<KeggRelation>(); //Relations to be removed
        List<KeggRelation> newRelations = new ArrayList<KeggRelation>(); //Relations to be added
        for (KeggRelation relation : relations) {
            if (relation.getSubtype1().equals(KeggRelation.COMPOUND) ||
                    relation.getSubtype2().equals(KeggRelation.COMPOUND)) {
                int id;
                id = relation.getSubtype1().equals(KeggRelation.COMPOUND) ?
                        Integer.parseInt(relation.getRelationValue1()) :
                        Integer.parseInt(relation.getRelationValue2());
                KeggNode compound = getNode(id);

                /*if (compound != null) {
                    KeggRelation relation1 = new KeggRelation(relation.getEntry1(), compound, relation.getType());
                    KeggRelation relation2 = new KeggRelation(compound, relation.getEntry2(), relation.getType());
                    relation1.addComment("Compound processed");
                    relation2.addComment("Compound processed");
                    relation1.setSubtype(relation.getSubtype1());
                    relation2.setSubtype(relation.getSubtype1());
                    relation1.setRelationValue(relation.getRelationValue1());
                    relation2.setRelationValue(relation.getRelationValue1());
                    if (relation.getSubtype2() != null) {
                        relation1.setSubtype(relation.getSubtype2());
                        relation2.setSubtype(relation.getSubtype2());
                        if (relation.getRelationValue2() != null) {
                            relation1.setRelationValue(relation.getRelationValue2());
                            relation2.setRelationValue(relation.getRelationValue2());
                        }
                    }
                    newRelations.add(relation1);
                    newRelations.add(relation2);
                    compoundRelations.add(relation);
                    System.out.println("Compound relation " + relation.toString() + " removed");
                    System.out.println("Compound relation " + relation1.toString() + " added");
                    System.out.println("Compound relation " + relation2.toString() + " added");
                }*/
                if (compound != null) {
                    KeggRelation relation1 = new KeggRelation(relation.getEntry1(), compound, relation.getType());
                    KeggRelation relation2 = new KeggRelation(compound, relation.getEntry2(), relation.getType());
                    relation1.addComment("Compound processed");
                    relation2.addComment("Compound processed");
                    if (relation.getSubtype1().equals(KeggRelation.COMPOUND)) {
                        if (relation.getSubtype2() != null && !relation.getSubtype2().equals(KeggRelation.COMPOUND)) {
                            relation1.setSubtype(relation.getSubtype2());
                            relation2.setSubtype(relation.getSubtype2());
                            if (relation.getRelationValue2() != null) {
                                relation1.setRelationValue(relation.getRelationValue2());
                                relation2.setRelationValue(relation.getRelationValue2());
                            }
                        }
                    } else if (!relation.getSubtype2().equals(KeggRelation.COMPOUND)) {
                        relation1.setSubtype(relation.getSubtype1());
                        relation2.setSubtype(relation.getSubtype1());
                        if (relation.getRelationValue1() != null) {
                            relation1.setRelationValue(relation.getRelationValue1());
                            relation2.setRelationValue(relation.getRelationValue1());
                        }
                    }

                    newRelations.add(relation1);
                    newRelations.add(relation2);
                    compoundRelations.add(relation);

                    ParsingReportGenerator.getInstance().append(relation.toString() + " removed");
                    ParsingReportGenerator.getInstance().append(relation1.toString() + " added");
                    ParsingReportGenerator.getInstance().append(relation2.toString() + " added");
                }
            }
        }
        if (compoundRelations.size() > 0)
            for (KeggRelation relation : compoundRelations) {
                removeRelation(relation);
            }
        if (newRelations.size() > 0)
            for (KeggRelation relation : newRelations) {
                addRelation(relation);
            }
        ParsingReportGenerator.getInstance().appendLine("Finished processing compound relations");
    }

    public void correctEdgeDirections() {
        /*If relations are from higher Id to lower, leave it as it is.
        * Otherwise, check, if the second node lies lefter of higher than the first one, reverse the edge.
        * */
        List<KeggRelation> reverseEdges = new ArrayList<KeggRelation>();
        for (KeggRelation relation : relations) {
            if (relation.getSubtype1().equals(KeggRelation.BINDING) ||
                    relation.getSubtype2().equals(KeggRelation.BINDING))
                if (relation.getEntry1().getId() < relation.getEntry2().getId()) {
                    if (isReverseDirection(relation))
                        reverseEdges.add(relation);
                }
        }
        ParsingReportGenerator.getInstance().appendLine("Correction of edge direactions ON");
        for (KeggRelation relation : reverseEdges) {
            reverseEdge(relation);
            ParsingReportGenerator.getInstance().append(relation.toString() + " reversed");
        }
        ParsingReportGenerator.getInstance().appendLine("Finished correcting edge directions");

    }

    public void guessEdgeDirections() {
        LinkedList<KeggRelation> bindings = new LinkedList<KeggRelation>();
        for (KeggRelation relation : relations) {
            if (relation.getSubtype1().equals(KeggRelation.BINDING) ||
                    relation.getSubtype2().equals(KeggRelation.BINDING)) {
                bindings.add(relation);
            }
        }
        int n = bindings.size();
        KeggNode node1, node2;
        List<KeggRelation> incidentEdges;
        for (int it = 0; it < n; it++) {
            for (KeggRelation binding : bindings) {
                node1 = binding.getEntry1();
                node2 = binding.getEntry2();
                if (node1.guessBindingDir() != null) {

                }
            }
        }
    }

    private boolean isReverseDirection(KeggRelation relation) {
        KeggNode node1 = relation.getEntry1();
        KeggNode node2 = relation.getEntry2();
        if (node1.getX() - node2.getX() != 0)
            return node1.getX() > node2.getX();
        else
            return node1.getY() > node2.getY();
    }

    public void reverseEdge(KeggRelation relation) {
        KeggRelation reversed = relation.clone();
        reversed.setEntry1(relation.getEntry2());
        reversed.setEntry2(relation.getEntry1());
        reversed.addComment("Reversed");
        removeRelation(relation);
        addRelation(reversed);
    }

    @Override
    public String toString() {
        return "Graph{" +
                "name='" + name + '\'' +
                ", organism='" + organism + '\'' +
                ", number='" + number + '\'' +
                ", title='" + title + '\'' +
                ", image='" + image + '\'' +
                ", link='" + link + '\'' +
                ", \nnodes=" + nodes +
                ", \nrelations=" + relations +
                '}';
    }
}
